#include "algorithm_raw.h"
#include <iostream>
#include <windows.h>
algorithm_raw::algorithm_raw(std::string goal, int population_size, int mutation_chance)
{
	_goal = goal;
	_population_size = population_size;
	_mutation_chance = mutation_chance;
	_generation_count = 0;

	_population = new population_raw(goal);
	_population->initialize(_population_size);
	random_number_generator.seed(std::random_device()());
}

//Destructor to free memory
algorithm_raw::~algorithm_raw()
{
	delete _population;
	_mating_pool.clear();
}

//Main loop for the algorithm
void algorithm_raw::run()
{
	_population->calculate_fitness();
	std::cout << "Generation: " << _generation_count << ", fittest: " << _population->get_fittest_individual()->get_gene() << "(" << _population->get_fittest_individual()->get_fitness() << ")" << std::endl;
	while (_generation_count < 3000) {
		_generation_count++;
		selection();
		create_new_generation();
		_population->calculate_fitness();

		std::cout << "Generation: " << _generation_count << ", fittest: " << _population->get_fittest_individual()->get_gene() << "(" << _population->get_fittest_individual()->get_fitness() << ")" << std::endl;
		double total_fitness = _population->get_total_fitness();
		int average_fitness = ((total_fitness / _population_size) / (double)_goal.length()) * 100;
		std::cout << "Average fitness: " << average_fitness << "%" << std::endl;
	}
}

//Roulette wheel selection
void algorithm_raw::selection()
{
	_mating_pool.clear();
	_population->calculate_fitness();

	for (int i = 0; i < _population_size; i++) {
		individual_raw* individual = _population->get_individual(i);
		for (auto j = 0; j < individual->get_fitness(); j++) {
			_mating_pool.push_back(individual);
		}
	}
}

//Crossover 2 individuals.
//1: Pick a random crossover point
//2: Swap the individual's genes at that crossover point
//3: Return the child generated by this crossover.
individual_raw* algorithm_raw::crossover(individual_raw & parent_a, individual_raw & parent_b)
{
	std::uniform_int_distribution<std::mt19937::result_type> random_distribution(1, _goal.size() - 1); //Make sure the first and last can't be crossover points
	individual_raw * child = new individual_raw(_goal);
	int crossover_point = random_distribution(random_number_generator);
	for (int i = 0; i < _goal.length(); i++) {
		if (i > crossover_point) {
			child->manipulate_gene(i, parent_a.get_gene()[i]);
		}
		else {
			child->manipulate_gene(i, parent_b.get_gene()[i]);
		}
	}

	return child;
}

//Creates a new generation.
//1: Get 2 random individuals from the mating pool
//2: Generate a child by doing crossover
//3: Mutate the child (1% chance by default).
//4: Add the child to the new population.
//5: Set the new population
void algorithm_raw::create_new_generation()
{
	std::vector<individual_raw*> new_population;
	new_population.reserve(_population_size);
	std::uniform_int_distribution<std::mt19937::result_type> random_distribution(0, _mating_pool.size() - 1);

	for (int i = 0; i < _population_size; i++) {
		int random_number1 = random_distribution(random_number_generator);
		int random_number2 = random_distribution(random_number_generator);
		individual_raw* parent_a = _mating_pool[random_number1];
		individual_raw* parent_b = _mating_pool[random_number2];
		individual_raw* child = crossover(*parent_a, *parent_b);
		child->mutate(_mutation_chance);
		new_population.push_back(child);
	}

	_population->set_new_population(new_population);
}


